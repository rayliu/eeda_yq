package controllers.eeda;import java.io.BufferedReader;import java.io.File;import java.io.IOException;import java.io.InputStreamReader;import java.io.LineNumberReader;import java.lang.management.ManagementFactory;import java.math.BigDecimal;import com.jfinal.core.Controller;import com.jfinal.log.Log;import com.sun.management.OperatingSystemMXBean;public class SysInfoController extends Controller {    private static Log logger = Log.getLog(SysInfoController.class);    private static final int CPUTIME = 500;    private static final int PERCENT = 100;    private static final int FAULTLENGTH = 10;    public static void main(String[] args) throws IOException {//        logger.debug(String.valueOf(getLinuxCpuUsage()));        // logger.debug(getMem());        // System.out.println(getDisk());        System.out.println(mem());    }    // 获取内存使用率    public void getMem() {        OperatingSystemMXBean osmxb = (OperatingSystemMXBean) ManagementFactory                .getOperatingSystemMXBean();        // 总的物理内存+虚拟内存        long totalvirtualMemory = osmxb.getTotalSwapSpaceSize();        // 剩余的物理内存        long freePhysicalMemorySize = osmxb.getFreePhysicalMemorySize();        Double compare = (Double) (1 - freePhysicalMemorySize * 1.0                / totalvirtualMemory) * 100;        // String str = "内存已使用:" + compare.intValue() + "%";        BigDecimal b = new BigDecimal(compare);        double f1 = b.setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue();        renderText(String.valueOf(f1));        // return compare.toString();    }    // 获取文件系统使用率    public static String getDisk() {        // 操作系统        String str = "";        /* Get a list of all filesystem roots on this system */        File[] roots = File.listRoots();        /* For each filesystem root, print some info */        for (File root : roots) {            str += "File system root: " + root.getAbsolutePath() + "\n";            str += "Total space: " + root.getTotalSpace() / 1024 / 1024 + "M\n";            str += "Free space: " + root.getFreeSpace() / 1024 / 1024 + "M\n";            str += "Usable space: " + root.getUsableSpace() / 1024 / 1024                    + "M\n";        }        return str;    }    public void getLinuxCpuUsage() throws IOException {        double cpuUsed = 0;        double idleUsed = 0.0;        Runtime rt = Runtime.getRuntime();        Process p = rt.exec("top -b -n 1");// call "top" command in linux        BufferedReader in = null;        // try        {            in = new BufferedReader(new InputStreamReader(p.getInputStream()));            // in = new BufferedReader(new InputStreamReader(System.in));            String str = null;            int linecount = 0;            while ((str = in.readLine()) != null) {                linecount++;                if (linecount == 3) {                    String[] s = str.split("%");                    String idlestr = s[3];                    String idlestr1[] = idlestr.split(" ");                    idleUsed = Double                            .parseDouble(idlestr1[idlestr1.length - 1]);                    // System.out.println("IdleUsed:XXXXXXXXXXXX"+idleUsed);                    cpuUsed = 100 - idleUsed;                    // System.out.println(cpuUsed);                    break;                }            }            // System.out.println(str);        }        // }        /*         * } catch (Exception e) { e.printStackTrace(); } finally { in.close();         * }         */        renderText(String.valueOf(cpuUsed));    }    // 获得cpu使用率    public static String getCpuRatioForWindows() {        try {            String procCmd = System.getenv("windir")                    + "//system32//wbem//wmic.exe process get Caption,CommandLine,KernelModeTime,ReadOperationCount,ThreadCount,UserModeTime,WriteOperationCount";            // 取进程信息            long[] c0 = readCpu(Runtime.getRuntime().exec(procCmd));            Thread.sleep(CPUTIME);            long[] c1 = readCpu(Runtime.getRuntime().exec(procCmd));            if (c0 != null && c1 != null) {                long idletime = c1[0] - c0[0];                long busytime = c1[1] - c0[1];                return "CPU使用率:"                        + Double.valueOf(                                PERCENT * (busytime) * 1.0                                        / (busytime + idletime)).intValue()                        + "%";            } else {                return "CPU使用率:" + 0 + "%";            }        } catch (Exception ex) {            ex.printStackTrace();            return "CPU使用率:" + 0 + "%";        }    }    // 读取cpu相关信息    private static long[] readCpu(final Process proc) {        long[] retn = new long[2];        try {            proc.getOutputStream().close();            InputStreamReader ir = new InputStreamReader(proc.getInputStream());            LineNumberReader input = new LineNumberReader(ir);            String line = input.readLine();            if (line == null || line.length() < FAULTLENGTH) {                return null;            }            int capidx = line.indexOf("Caption");            int cmdidx = line.indexOf("CommandLine");            int rocidx = line.indexOf("ReadOperationCount");            int umtidx = line.indexOf("UserModeTime");            int kmtidx = line.indexOf("KernelModeTime");            int wocidx = line.indexOf("WriteOperationCount");            long idletime = 0;            long kneltime = 0;            long usertime = 0;            while ((line = input.readLine()) != null) {                if (line.length() < wocidx) {                    continue;                }                // 字段出现顺序：Caption,CommandLine,KernelModeTime,ReadOperationCount,                // ThreadCount,UserModeTime,WriteOperation                String caption = substring(line, capidx, cmdidx - 1).trim();                String cmd = substring(line, cmdidx, kmtidx - 1).trim();                if (cmd.indexOf("wmic.exe") >= 0) {                    continue;                }                String s1 = substring(line, kmtidx, rocidx - 1).trim();                String s2 = substring(line, umtidx, wocidx - 1).trim();                if (caption.equals("System Idle Process")                        || caption.equals("System")) {                    if (s1.length() > 0)                        idletime += Long.valueOf(s1).longValue();                    if (s2.length() > 0)                        idletime += Long.valueOf(s2).longValue();                    continue;                }                if (s1.length() > 0)                    kneltime += Long.valueOf(s1).longValue();                if (s2.length() > 0)                    usertime += Long.valueOf(s2).longValue();            }            retn[0] = idletime;            retn[1] = kneltime + usertime;            return retn;        } catch (Exception ex) {            ex.printStackTrace();        } finally {            try {                proc.getInputStream().close();            } catch (Exception e) {                e.printStackTrace();            }        }        return null;    }    public static String mem() {        String str = "";        /* Total number of processors or cores available to the JVM */        str += "Available processors (cores): "                + Runtime.getRuntime().availableProcessors() + "\n";        /* Total amount of free memory available to the JVM */        str += "Free memory: " + Runtime.getRuntime().freeMemory() / 1024                / 1024 + "M\n";        /* This will return Long.MAX_VALUE if there is no preset limit */        long maxMemory = Runtime.getRuntime().maxMemory();        /* Maximum amount of memory the JVM will attempt to use */        str += "Maximum memory: "                + (maxMemory == Long.MAX_VALUE ? "no limit"                        : maxMemory / 1024 / 1024) + "M\n";        /* Total memory currently available to the JVM */        str += "Total memory available to JVM: "                + Runtime.getRuntime().totalMemory() / 1024 / 1024 + "M\n\n";        /* Get a list of all filesystem roots on this system */        File[] roots = File.listRoots();        /* For each filesystem root, print some info */        for (File root : roots) {            str += "File system root: " + root.getAbsolutePath() + "\n";            str += "Total space: " + root.getTotalSpace() / 1024 / 1024 + "M\n";            str += "Free space: " + root.getFreeSpace() / 1024 / 1024 + "M\n";            str += "Usable space: " + root.getUsableSpace() / 1024 / 1024                    + "M\n";        }        return str;    }    /**     * 由于String.subString对汉字处理存在问题（把一个汉字视为一个字节)，因此在 包含汉字的字符串时存在隐患，现调整如下：     *      * @param src     *            要截取的字符串     * @param start_idx     *            开始坐标（包括该坐标)     * @param end_idx     *            截止坐标（包括该坐标）     * @return     */    private static String substring(String src, int start_idx, int end_idx) {        byte[] b = src.getBytes();        String tgt = "";        for (int i = start_idx; i <= end_idx; i++) {            tgt += (char) b[i];        }        return tgt;    }}